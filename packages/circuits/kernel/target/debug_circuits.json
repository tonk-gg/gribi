{"debug_symbols":[{"locations":{"0":[{"span":{"start":804,"end":976},"file":0}]}}],"file_map":{"0":{"source":"use dep::std;\n\nfn main(\n    verification_key: [Field; 114],\n    proof: [Field; 94],\n    // 1. need some way to check the verification keys, hash them? deploy a versioned verifier with vk key hashes\n    // other details to convert from Field to solidity type should be handled in codegen? \n    // 2. [current_state_representation] can be used as identifier??\n    // 3. flag governing this circuit computes for the state a [commit, update, nonce reveal, nullifier gen]\n    // 2. [new_state_representation, usually a hash, or if revealing, just the normal value of the state]\n    public_inputs: [Field; 3],// this is where all the interesting shit will live\n    key_hash: Field,\n    input_aggregation_object: [Field; 16]\n) -> pub [Field; 4] {\n    // let empty_aggregation_object: [Field; 16] = [0; 16];\n    std::verify_proof(\n        verification_key.as_slice(),\n        proof.as_slice(),\n        public_inputs.as_slice(),\n        key_hash,\n        input_aggregation_object\n    );\n\n    let mut output: [Field; 4] = [0; 4];\n    output[0] = public_inputs[0];\n    output[1] = public_inputs[1];\n    output[2] = public_inputs[2];\n    output[3] = key_hash;\n    output\n}\n\n// #[test]\n// fn test_main() {\n//     main(1, 2);\n//     // Uncomment to make test fail\n//     // main(1, 1);\n// }\n","path":"/Users/goblin/Workspace/gribi/packages/circuits/src/main.nr"}},"warnings":[{"Warning":{"VerifyProof":{"call_stack":[{"span":{"start":804,"end":976},"file":0}]}}}]}