{"noir_version":"0.25.0+3f676051a6073d6eabdc7fee68e4b522334344f6","hash":12982129222387762712,"abi":{"parameters":[{"name":"input","type":{"kind":"array","length":7,"type":{"kind":"field"}},"visibility":"private"}],"param_witnesses":{"input":[{"start":0,"end":7}]},"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"return_witnesses":[7]},"bytecode":"H4sIAAAAAAAA/92USw7CMAxEneYHQkJwA44QJCRY9v6nog62mCJ2dRauN3EddfxGllOJKNAnIuR8VlqH3s1ytm1xN9RqoxiDA8bJAWN0wJgcMGYHjMWQUdk4+D26Sn6A+s2q36O9mJ3Stx8G95zsezbWjda6yxwqeDhxLr7UwwVqATymASwBPKq2fqf99u6zLfa6z/OicYRZlh8/Wc4+9z81/U/vWAt3rcc8YAC4VEFAooBnMEIAtFrENys1Mb+yCAAA","debug_symbols":"tZJBCsMgEEXvMmspGqsmXqV0YVMLgpgQbaGId6+Spi2kmxDczWf+e6sfwQ69CmZwHmQEDPIUwY/KleSDmgLIhjEE2l3zxXlCcDNWgzyKdEaAD2I70m5Hun8I52+io78AWhUJYUs1n+JTpni2E1xXT3bqG/zVt2t9U1dPq+lzeKjJqIvVZX7ld3f9ssYcw3OcP+kF","file_map":{"30":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\nmod pedersen;\n\nuse crate::default::Default;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\nstruct PedersenPoint {\n   x : Field,\n   y : Field,\n}\n\npub fn pedersen_commitment<N>(input: [Field; N]) -> PedersenPoint\n// docs:end:pedersen_commitment\n{\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> PedersenPoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    PedersenPoint { x: values[0], y: values[1] }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field<N>(input: [Field; N]) -> Field {\n    let mut inputs_as_bytes = [];\n\n    for i in 0..N {\n        let input_bytes = input[i].to_le_bytes(32);\n        for i in 0..32 {\n            inputs_as_bytes = inputs_as_bytes.push_back(input_bytes[i]);\n        }\n    }\n\n    let hashed_input = blake2s(inputs_as_bytes);\n    crate::field::bytes32_to_field(hashed_input)\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: [Field]);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\n// TODO: add implementations for the remainder of primitive types.\nimpl Hash for Field{\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        let input: [Field] = [self];\n        H::write(state, input);\n    }\n}\n","path":"std/hash.nr"},"47":{"source":"use dep::std;\nunconstrained fn hash(i: [Field; 7]) -> Field {\n    std::hash::pedersen_hash(i)\n}\n\n//If we wish to complicate the helpers here maybe we can be more creative? Or find a way to work with libraries\nfn main(input: [Field; 7]) -> pub Field {\n    hash(input)\n}\n\n#[test]\nfn test_main() {\n    println(main([1, 2, 0, 0, 0, 0, 0]));\n    // Uncomment to make test fail\n    // main(1, 1);\n}\n","path":"/Users/goblin/Workspace/gribi/packages/circuits/helpers/src/main.nr"}}}